<!DOCTYPE HTML>
<html lang="en-GB">
<head>

<!-- Technical meta -->
<base target="_blank">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, shrink-to-fit=no, maximum-scale=1.0, user-scalable=no">

<!-- Search engine meta -->
<title>Threecap Tryout</title>
<meta name="description"
      content="A basic tryout of threecap">
<link rel="author" href="README.md">

<!-- Threecap and Scene styles -->
<link rel="stylesheet" type="text/css" href="css/threecapui.css">
<style>
  body { margin: 0; }
  canvas { width:854px; height:480px; } /* becomes 1920x1080 during capture */
  #recordpanel input { width:200px; }
  #recordpanel div { opacity:0; height:0 }
  #recordpanel div:last-of-type { position:relative; opacity:1; height:auto; z-index:999 }
</style>

</head>
<body>

<h1>Threecap Tryout</h1>
<h4>A basic tryout of <a href="https://github.com/jbaicoianu/threecap">threecap</a></h4>
<p>
  <a href="https://github.com/richplastow/threecap-tryout">Repo</a> &nbsp;
  <a href="http://richplastow.com/threecap-tryout/">Demo</a>
</p>
<p>
<button onclick="window.restartForPreview()">Restart</button>
<pre></pre>

<!-- Load the data -->
<script>
  window.registerData = function (data) {
      window.worldcities = data
  }
</script>
<script src="data/worldcities.js"></script>

<!-- THREE.js -->
<script src="js/three.min.js"></script>

<!-- THREE.js postprocessing -->
<script src="js/EffectComposer.js"></script>
<script src="js/ShaderPass.js"></script>
<script src="js/MaskPass.js"></script>
<script src="js/RenderPass.js"></script>

<!-- THREE.js shaders -->
<script src="js/CopyShader.js"></script>
<script src="js/RGBShiftShader.js"></script>

<!-- Threecap -->
<script src="threecap-master/build/threecap.js"></script>

<!-- TWEEN.js -->
<script type='text/javascript' src='js/tween.min.js'></script>


<!-- Create and animate the scene -->
<script>!function (ROOT) {




    //// CONFIG, CONSTANTS, STATE
    const

        //// Config.
        showDuringCapture = false

        //// Dimensions, frame rate, duration.
      , width = 854
      , height = 480
      , fps = 25
      , duration = 1000 // in ms

      , captureWidth = 1920
      , captureHeight = 1080
      , captureFps = 1
      , captureDuration = duration * (fps / captureFps)

      , pixelRatio = ROOT.devicePixelRatio || 0

        //// THREE constant objects.
	  , clock = new THREE.Clock()
      , scene = new THREE.Scene()
      // , cameraWrap = new THREE.Object3D
      , camera = new THREE.PerspectiveCamera(35, width/height, 0.1, 1000)
      , renderer = new THREE.WebGLRenderer({ antialias:true })
	  , composer = new THREE.EffectComposer(renderer)
	  // , rgbShiftPass = new THREE.ShaderPass(THREE.RGBShiftShader)
	  , copyPass = new THREE.ShaderPass(THREE.CopyShader)

        //// Globe and sprites.
      , globe = new THREE.Object3D()
      , textureLoader = new THREE.TextureLoader()
      , texture = textureLoader.load('img/circle-transparent.png')
      , material = new THREE.SpriteMaterial({
            map: texture
          , color:0xffffff
          , blending: THREE.AdditiveBlending
          , depthTest: false
          , transparent: true
          , fog:true
        })
      , sprites = []

        //// Capture.
      , capture = new THREEcap({
            width: captureWidth
          , height: captureHeight
          , fps: captureFps
          , time: captureDuration / 1000 // convert ms to seconds
          , format: 'mp4'
          // , canvas: renderer.domElement // optional, slowest
          , composer: composer // faster than using a canvas
          , scriptbase: 'threecap-master/build/'
        })
      , captureui = new THREEcapUI(capture)
      // , threecap = new THREEcap()

        //// Tween.
      , cameraStart  = { lat:12.96999514, lon:77.56000972, alt:150 }
      // , cameraStart  = { lat:0, lon:0, alt:300 }

    //// Current state.
    let
        currFps
      , currDuration
      , cameraCurr   = Object.assign({}, cameraStart)
      // , cameraTarget = Object.assign({}, cameraStart)
      , cameraTarget = { lat:-1.283346742, lon:36.81665686, alt:130 }
      , cameraTween = { // will be `new TWEEN.Tween(cameraCurr).to(cameraTarget, 123)`
            stop: () => {}
        }



ROOT.captureui = captureui

    //// SCENE


    //// Set up the scene.
	renderer.setPixelRatio(pixelRatio)
	renderer.autoClear = false
	composer.addPass( new THREE.RenderPass(scene, camera) )
	// rgbShiftPass.uniforms.amount.value = 0.0015
    // rgbShiftPass.renderToScreen = true
	// composer.addPass(rgbShiftPass)
	composer.addPass(copyPass)
    // cameraWrap.add(camera)
    // scene.add(cameraWrap)
    // globe.rotation.x = - Math.PI / 2
    // camera.rotation.x = - Math.PI / 2
    scene.add(camera)
    scene.add(globe)
	scene.fog = new THREE.FogExp2(0x000080, 0.004)
    document.body.appendChild(renderer.domElement)
    restartForPreview()

    //// Add a circle sprite for every item in the data.
    for (let i=1; i<window.worldcities.length; i++) { // i=1, ignore header line
        const sprite = new THREE.Sprite(material)
        const [ pop, city, x, y, z ] = window.worldcities[i]
        sprite.position.set(x, y, z)
        sprite.scale.set(2,2,2)
        sprites.push(sprite)
        globe.add(sprite)
    }




    //// CAPTURE

    const $recordpanel = document.querySelector('#recordpanel')
    $recordpanel.querySelector('button').addEventListener('mousedown', function (e) {
        onRecordButtonClick()
        captureui.settings.framerate = captureFps
        captureui.settings.resolution = `${captureWidth}x${captureHeight}`
        captureui.settings.time = captureDuration / 1000 // convert ms to seconds
        const oldFilename = captureui.settings.filename
        captureui.settings.filename += '.' + captureui.settings.format
        console.log(captureui.settings);
        document.querySelector('pre').innerHTML =
            `mv $HOME/Downloads/'${captureui.settings.filename}' `
          + `'./${captureui.settings.filename}'; \n`
          + `./ffmpeg -i '${captureui.settings.filename}' -r ${fps} -filter:v `
          + `"setpts=${captureFps / fps}*PTS" `
          + `'${oldFilename}-${fps}fps.${captureui.settings.format}'; \n`
          + `unlink '${captureui.settings.filename}'`
    })




    //// RENDER


    //// Renders the scene.
    function animate () {
    	requestAnimationFrame(animate)
		const delta = clock.getDelta() // needed, to enable `clock.elapsedTime`

        // cameraWrap.rotation.y += 0.005 * currFps * delta
        // if (2 < clock.elapsedTime) {
        //     //// 20.992118041621335, 95.16088704980827, 22.44407618994976
        //     cameraWrap.rotation.y += stepTowards() * currFps * delta
        // } else {
        //     cameraWrap.rotation.y += 0.005 * currFps * delta
        // }
	    TWEEN.update(clock.elapsedTime * 1000) // convert seconds to ms
		renderer.clear()
		composer.render(0.01)
    }
    // //// Moves and turns the camera towards a city.
    // //// Returns 0.005 when far away, which tweens to 0 when arrived -
    // //// a number which should be added to `cameraWrap.rotation.y`.
    // function stepTowards () {
    //     camera.position.z -= 1.8 * currFps * delta
    //     return 0.002
    // }

    ////
    function onUpdate () {
        setToPolarPosition(camera, cameraCurr.lat, cameraCurr.lon, cameraCurr.alt)
        camera.lookAt(0,0,0)
    }

    //// Begin Rendering.
    animate()




    //// FUNCTIONS


    //// Resets the scene state and zeros the timer.
    function restart () {
        cameraTween.stop()
        TWEEN.removeAll()
        cameraCurr = Object.assign({}, cameraStart)
        onUpdate()
        cameraTween =
            new TWEEN.Tween(cameraCurr)
           .to(cameraTarget, currDuration)
           .easing(TWEEN.Easing.Cubic.InOut)
           .onUpdate(onUpdate)
           .start()
    }

    //// Restarts the scene for development and previewing.
    ROOT.restartForPreview = restartForPreview
    function restartForPreview () {
        copyPass.renderToScreen = true
        currFps = fps
        currDuration = duration
        renderer.setSize(width, height)
        composer.setSize(width * pixelRatio, height * pixelRatio)
        restart()
    }


    //// Restarts the scene for capture.
    ROOT.restartForCapture = restartForCapture
    function restartForCapture () {
        copyPass.renderToScreen = showDuringCapture
        currFps = captureFps
        currDuration = captureDuration
        console.log(currFps, currDuration)
        renderer.setSize(captureWidth, captureHeight)
        composer.setSize(captureWidth * pixelRatio, captureHeight * pixelRatio)
        restart()
    }


    //// Restarts the scene for capturing, runs the capture and saves the video.
    function onRecordButtonClick () {
        restartForCapture()

        // threecap.record({
        //     width: captureWidth
        //   , height: captureHeight
        //   , fps: captureFps
        //   , time: duration * (fps / captureFps)
        //   , format: 'mp4'
        //   // , canvas: renderer.domElement // optional, slowest
        //   , composer: composer // optional, fastest
        //   , scriptbase: './threecap-master/build/'
        // }).then(function(video) {
        //     video.saveFile('myVideo.mp4')
        // })
    }


    function setToPolarPosition (object3d, lat, lon, alt) {
        // lat = Math.PI / 2 - lat // Flip the Y axis
        const cosLat = Math.cos(lat * Math.PI / 180)
        const sinLat = Math.sin(lat * Math.PI / 180)
        const cosLon = Math.cos(lon * Math.PI / 180)
        const sinLon = Math.sin(lon * Math.PI / 180)
        // camera.position.set.apply(this, latLonAltToXYZ(0, 0, 600) )
        // console.log( latLonAltToXYZ(0, 0, 600), camera.position )
        const x = alt * cosLat * cosLon
        const y = alt * cosLat * sinLon
        const z = alt * sinLat
        object3d.position.x = x
        object3d.position.y = z   // for correct THREE.js coords, swap y with z...
        object3d.position.z = - y // ...and z with -y
    }


}(this)</script>

</body>
</html>
