<!DOCTYPE HTML>
<html lang="en-GB">
<head>

<!-- Technical meta -->
<base target="_blank">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, shrink-to-fit=no, maximum-scale=1.0, user-scalable=no">

<!-- Search engine meta -->
<title>Threecap Tryout</title>
<meta name="description"
      content="A basic tryout of threecap">
<link rel="author" href="README.md">

<!-- Threecap and Scene styles -->
<link rel="stylesheet" type="text/css" href="css/threecapui.css">
<style>
  body { margin: 0; }
  canvas { width:854px; height:480px; } /* becomes 1920x1080 during capture */
  #recordpanel input { width:200px; }
  #recordpanel div { opacity:0; height:0 }
  #recordpanel div:last-of-type { opacity:1; height:auto }
</style>

</head>
<body>

<h1>Threecap Tryout</h1>
<h4>A basic tryout of <a href="https://github.com/jbaicoianu/threecap">threecap</a></h4>
<p>
  <a href="https://github.com/richplastow/threecap-tryout">Repo</a> &nbsp;
  <a href="http://richplastow.com/threecap-tryout/">Demo</a>
</p>
<p>
<button onclick="window.restartForPreview()">Restart</button>
<pre></pre>

<!-- Load the data -->
<script>
  window.registerData = function (data) {
      window.worldcities = data
  }
</script>
<script src="data/worldcities.js"></script>

<!-- THREE.js -->
<script src="js/three.min.js"></script>

<!-- THREE.js postprocessing -->
<script src="js/EffectComposer.js"></script>
<script src="js/ShaderPass.js"></script>
<script src="js/MaskPass.js"></script>
<script src="js/RenderPass.js"></script>

<!-- THREE.js shaders -->
<script src="js/CopyShader.js"></script>
<script src="js/RGBShiftShader.js"></script>

<!-- Threecap -->
<script src="threecap-master/build/threecap.js"></script>

<!-- Create and animate the scene -->
<script>!function (ROOT) {




    //// CONFIG, CONSTANTS, STATE
    const

        //// Config.
        hideDuringCapture = false

        //// Dimensions, frame rate, duration.
      , width = 854
      , height = 480
      , fps = 25
      , duration = 3 // in seconds
      , captureWidth = 1920
      , captureHeight = 1080
      , captureFps = 1
      , captureDuration = duration * (fps / captureFps)
      , pixelRatio = ROOT.devicePixelRatio || 0

        //// THREE constant objects.
	  , clock = new THREE.Clock()
      , scene = new THREE.Scene()
      , camera = new THREE.PerspectiveCamera(35, width/height, 0.1, 1000)
      , renderer = new THREE.WebGLRenderer({ antialias:true })
	  , composer = new THREE.EffectComposer(renderer)
	  // , rgbShiftPass = new THREE.ShaderPass(THREE.RGBShiftShader)
	  , copyPass = new THREE.ShaderPass(THREE.CopyShader)

        //// Globe and sprites.
      , globe = new THREE.Object3D()
      , textureLoader = new THREE.TextureLoader()
      , texture = textureLoader.load('img/circle-transparent.png')
      , material = new THREE.SpriteMaterial({
            map: texture
          , color:0xffffff
          , blending: THREE.AdditiveBlending
          , depthTest: false
          , transparent: true
          , fog:true
        })
      , sprites = []

        //// Capture.
      , capture = new THREEcap({
            width: captureWidth
          , height: captureHeight
          , fps: captureFps
          , time: captureDuration
          , format: 'mp4'
          // , canvas: renderer.domElement // optional, slowest
          , composer: composer // faster than using a canvas
          , scriptbase: 'threecap-master/build/'
        })
      , captureui = new THREEcapUI(capture)
      // , threecap = new THREEcap()

    //// Current state.
    let
        currFps
      , currDuration



ROOT.captureui = captureui

    //// SCENE


    //// Set up the scene.
    clock.stop()
	renderer.setPixelRatio(pixelRatio)
	renderer.autoClear = false
	composer.addPass( new THREE.RenderPass(scene, camera) )
	// rgbShiftPass.uniforms.amount.value = 0.0015
    // rgbShiftPass.renderToScreen = true
	// composer.addPass(rgbShiftPass)
	composer.addPass(copyPass)

    document.body.appendChild(renderer.domElement)
    scene.add(globe)
	scene.fog = new THREE.FogExp2(0x000080, 0.004)
    restartForPreview()

    //// Add a circle sprite for every item in the data.
    for (let i=1; i<window.worldcities.length; i++) { // i=1, ignore header line
        const sprite = new THREE.Sprite(material)
        const [ pop, city, x, y, z ] = window.worldcities[i]
        sprite.position.set(x, y, z)
        sprite.scale.set(2,2,2)
        sprites.push(sprite)
        globe.add(sprite)
    }




    //// CAPTURE

    const $recordpanel = document.querySelector('#recordpanel')
    $recordpanel.querySelector('button').addEventListener('mousedown', function (e) {
        onRecordButtonClick()
        captureui.settings.framerate = captureFps
        captureui.settings.resolution = `${captureWidth}x${captureHeight}`
        captureui.settings.time = captureDuration
        const oldFilename = captureui.settings.filename
        captureui.settings.filename += '.' + captureui.settings.format
        document.querySelector('pre').innerHTML =
            `mv $HOME/Downloads/'${captureui.settings.filename}' `
          + `'./${captureui.settings.filename}'; \n`
          + `./ffmpeg -i '${captureui.settings.filename}' -r ${fps} -filter:v `
          + `"setpts=${captureFps / fps}*PTS" `
          + `'${oldFilename}-${fps}fps.${captureui.settings.format}'; \n`
          + `unlink '${captureui.settings.filename}'`
    })



    //// RENDER


    //// Renders the scene.
    function animate() {
    	requestAnimationFrame(animate)
        if ( currDuration < clock.elapsedTime ) return clock.stop()
		const delta = clock.getDelta()
        globe.rotation.z += (0.005 * currFps) * delta
		renderer.clear()
		composer.render(0.01)
    }

    //// Begin Rendering.
    animate()




    //// FUNCTIONS


    //// Resets the scene state and zeros the timer.
    function restart () {
        globe.rotation.x = - Math.PI / 2
        globe.rotation.z = Math.PI // start above India
        camera.position.z = 300
        clock.stop() // zeros the timer
        clock.start()
    }

    //// Restarts the scene for development and previewing.
    ROOT.restartForPreview = restartForPreview
    function restartForPreview () {
        copyPass.renderToScreen = true
        currFps = fps
        currDuration = duration
        renderer.setSize(width, height)
        composer.setSize(width * pixelRatio, height * pixelRatio)
        restart()
    }


    //// Restarts the scene for capture.
    function restartForCapture () {
        copyPass.renderToScreen = hideDuringCapture
        currFps = captureFps
        currDuration = captureDuration
        renderer.setSize(captureWidth, captureHeight)
        composer.setSize(captureWidth * pixelRatio, captureHeight * pixelRatio)
        restart()
    }


    //// Restarts the scene for capturing, runs the capture and saves the video.
    function onRecordButtonClick () {
        restartForCapture()

        // threecap.record({
        //     width: captureWidth
        //   , height: captureHeight
        //   , fps: captureFps
        //   , time: duration * (fps / captureFps)
        //   , format: 'mp4'
        //   // , canvas: renderer.domElement // optional, slowest
        //   , composer: composer // optional, fastest
        //   , scriptbase: './threecap-master/build/'
        // }).then(function(video) {
        //     video.saveFile('myVideo.mp4')
        // })
    }


}(this)</script>

</body>
</html>
