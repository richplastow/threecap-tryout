<!DOCTYPE HTML>
<html lang="en-GB">
<head>

<!-- Technical meta -->
<base target="_blank">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, shrink-to-fit=no, maximum-scale=1.0, user-scalable=no">

<!-- Search engine meta -->
<title>Threecap Tryout</title>
<meta name="description"
      content="A basic tryout of threecap">
<link rel="author" href="README.md">

<!-- Threecap and Scene styles -->
<link rel="stylesheet" type="text/css" href="css/threecapui.css">
<style>
  @font-face {
    font-family: 'museo_sans500';
    src: url('font/MuseoSans_500-webfont.eot');
    src: url('font/MuseoSans_500-webfont.eot?#iefix') format('embedded-opentype'),
         url('font/MuseoSans_500-webfont.woff2') format('woff2'),
         url('font/MuseoSans_500-webfont.woff') format('woff'),
         url('font/MuseoSans_500-webfont.ttf') format('truetype'),
         url('font/MuseoSans_500-webfont.svg#museo_sans500') format('svg');
    font-weight: normal;
    font-style: normal;
  }
  body { margin:0; background:silver; font-family:"museo_sans500" }
  #sprite-wrap { position:absolute; text-align:right; top:0; right:0 }
  #sprite-wrap canvas { width:64px; height:64px; display:inline-block }
  canvas#three-scene { width:854px; height:480px; } /* becomes 1920x1080 during capture */
  #recordpanel input { width:200px; }
  #recordpanel div { opacity:0; height:0 }
  #recordpanel div:last-of-type { position:relative; opacity:1; height:auto; z-index:999 }
</style>

</head>
<body>

<h1>Threecap Tryout</h1>
<p>
  A basic tryout of <a href="https://github.com/jbaicoianu/threecap">threecap</a> &nbsp; &nbsp;
  <a href="https://github.com/richplastow/threecap-tryout">Repo</a> &nbsp;
  <a href="http://richplastow.com/threecap-tryout/">Demo</a>
</p>
<input id="from" placeholder="From" value="Bangalore"></input>
<input id="to"   placeholder="To" value="Nairobi" onkeydown="
if (13 === event.keyCode) window.restartForPreview()"></input>
<button onclick="window.restartForPreview()">Restart</button>
<pre></pre>

<div id="sprite-wrap">

  <!-- Draw the sprite for ‘usual’ dots -->
  <canvas id="usual-sprite" width="256" height="256"></canvas>
  <script>!function(){
  const ctx = document.getElementById('usual-sprite').getContext('2d')
  ctx.fillStyle = 'rgb(0, 90, 83)'//'#00ff80'
  ctx.beginPath()
  ctx.arc(128, 128, 126, 0, Math.PI * 2) // x, y, r, start angle, end angle
  ctx.fill()
  }()</script>

  <!-- Draw the sprite for ‘from’ and ‘to’ dots -->
  <canvas id="from-and-to-sprite" width="256" height="256"></canvas>
  <script>!function(){
  const ctx = document.getElementById('from-and-to-sprite').getContext('2d')
  ctx.fillStyle = '#ffffff'
  ctx.beginPath()
  // ctx.fillRect(10,10,200,200)
  ctx.arc(128, 128, 126, 0, Math.PI * 2) // x, y, r, start angle, end angle
  ctx.fill()
  }()</script>

  <!-- Draw the sprite for ‘to’ text -->
  <canvas id="to-text-sprite" width="512" height="512"></canvas>
  <script>!function(){
  const ctx = document.getElementById('to-text-sprite').getContext('2d')
  ctx.fillStyle = '#ffffff'
  ctx.font = '72px museo_sans500'
  window.updateToText = function (text) {
      ctx.clearRect(0,0,512,512)
      ctx.fillText(text.toUpperCase(), 100, 250)
  }
  }()</script>

</div>

<!-- Load the data -->
<script>
  window.registerData = function (data) {
      window.worldcities = data
  }
</script>
<script src="data/worldcities.js"></script>

<!-- THREE.js -->
<script src="js/three.min.js"></script>

<!-- THREE.js postprocessing -->
<script src="js/EffectComposer.js"></script>
<script src="js/ShaderPass.js"></script>
<script src="js/MaskPass.js"></script>
<script src="js/RenderPass.js"></script>

<!-- THREE.js shaders -->
<script src="js/CopyShader.js"></script>
<script src="js/RGBShiftShader.js"></script>

<!-- Threecap -->
<script src="threecap-master/build/threecap.js"></script>

<!-- TWEEN.js -->
<script type='text/javascript' src='js/tween.min.js'></script>


<!-- Create and animate the scene -->
<script>!function (ROOT) {




    //// CONFIG, CONSTANTS, STATE
    const

        //// Config.
        showDuringCapture = false

        //// Dimensions, frame rate, duration.
      , width = 854
      , height = 480
      , fps = 25
      , duration = 8000 // in ms

        //// Visual.
      , usualSpriteOpacityBeginEnd = 0
      , usualSpriteOpacityFlying   = 1
      , fromSpriteOpacityBegin     = 1
      , toSpriteOpacityEnd         = 1
      , toTextSpriteOpacityFlying  = 0
      , toTextSpriteOpacityEnd     = 1

      , captureWidth  = 1920
      , captureHeight = 1080
      , captureFps    = 1
      , captureDuration = duration * (fps / captureFps)

      , pixelRatio = ROOT.devicePixelRatio || 0

        //// THREE constant objects.
	  , clock = new THREE.Clock()
      , scene = new THREE.Scene()
      // , cameraWrap = new THREE.Object3D
      , camera = new THREE.PerspectiveCamera(35, width/height, 0.1, 1000)
      , renderer = new THREE.WebGLRenderer({ antialias:true })
	  , composer = new THREE.EffectComposer(renderer)
	  // , rgbShiftPass = new THREE.ShaderPass(THREE.RGBShiftShader)
	  , copyPass = new THREE.ShaderPass(THREE.CopyShader)

        //// Globe and sprites.
      , globe = new THREE.Object3D()
      // , textureLoader = new THREE.TextureLoader()
      // , texture = textureLoader.load('img/circle-transparent.png')
      , usualSpriteTexture = new THREE.CanvasTexture(
            document.getElementById('usual-sprite')
        )
      , fromAndToSpriteTexture = new THREE.CanvasTexture(
            document.getElementById('from-and-to-sprite')
        )
      , toTextSpriteTexture = new THREE.CanvasTexture(
            document.getElementById('to-text-sprite')
        )
      , spriteMaterialTemplate = {
            map: usualSpriteTexture
          , blending: THREE.AdditiveBlending
          , depthTest: false
          , transparent: true
          , opacity: usualSpriteOpacityBeginEnd
          , fog:true
        }
      , usualSpriteMaterial = new THREE.SpriteMaterial(
            Object.assign({}, spriteMaterialTemplate)
        )
      , fromSpriteMaterial = new THREE.SpriteMaterial(
            Object.assign({}, spriteMaterialTemplate, {
                fog: false
              , map: fromAndToSpriteTexture
              , opacity: fromSpriteOpacityBegin
            })
        )
      , toSpriteMaterial = new THREE.SpriteMaterial(
            Object.assign({}, spriteMaterialTemplate, {
                fog: false
              , map: fromAndToSpriteTexture
            })
        )
      , toTextSpriteMaterial = new THREE.SpriteMaterial(
            Object.assign({}, spriteMaterialTemplate, {
                fog: false
              , map: toTextSpriteTexture
              , opacity: toTextSpriteOpacityFlying
            })
        )
      , sprites = []

        //// Capture.
      , capture = new THREEcap({
            width: captureWidth
          , height: captureHeight
          , fps: captureFps
          , time: captureDuration / 1000 // convert ms to seconds
          , format: 'mp4'
          // , canvas: renderer.domElement // optional, slowest
          , composer: composer // faster than using a canvas
          , scriptbase: 'threecap-master/build/'
        })
      , captureui = new THREEcapUI(capture)




    //// STATE
    let
        fromData
      , toData
      , prevNow = null
      , currMode = null // `null` to init, 'preview' or 'capture' after that
      , currFps = fps
      , currDuration = duration
      , cameraCurrent = {
            position: {
                lat: 0
              , lon: 0
              , alt: 0
            }
        }
      , fromSprite
      , toSprite
      , toTextSprite




    //// FROM / TO
    function resetFromTo () {
        const fromVal = document.getElementById('from').value
        const toVal = document.getElementById('to').value
        fromData = [ 0 ] // population zero...
        toData   = [ 0 ] // ...which simplifies big-city search
        for (let i=0; i<window.worldcities.length; i++) {
            const data = window.worldcities[i]
            if (fromVal === data[1]) // found a candidate city...
                if (fromData[0] < data[0]) // ...its pop is bigger than the previously found city...
                    fromData = data // ...so prefer it
            if (toVal === data[1])
                if (toData[0] < data[0])
                    toData = data
        }
        window.updateToText(toData[1])
        toTextSpriteMaterial.map.needsUpdate = true
        console.log('From', fromData[1], 'to', toData[1]);
    }
    resetFromTo()



    //// SPRITES


    //// Add a sprite for every location in the data.
    for (let i=1; i<window.worldcities.length; i++) { // i=1, ignore header line
        const [ pop, city, x, y, z ] = window.worldcities[i]
        const scale = Math.log(pop) / 8 // eg 2.27 for a million, 1.15 for 10000
        let sprite = new THREE.Sprite(usualSpriteMaterial)
        sprite.position.set(x, y, z)
        sprite.scale.set(scale, scale, scale)
        sprites.push(sprite)
        globe.add(sprite)
    }

    //// Add the ‘from’ and ‘to’ dots.
    fromSprite = new THREE.Sprite(fromSpriteMaterial)
    toSprite = new THREE.Sprite(toSpriteMaterial)
    globe.add(fromSprite)
    globe.add(toSprite)
    function resetFromToSprites () {
        fromSprite.position.set(fromData[2], fromData[3], fromData[4])
        toSprite.position.set(toData[2], toData[3], toData[4])
    }
    resetFromToSprites()

    //// Add the text which goes next to the ‘to’ dot.
    toTextSprite = new THREE.Sprite(toTextSpriteMaterial)
    toTextSprite.scale.set(40,40,40)
    globe.add(toTextSprite)
    function resetTextSprites () {
        // const toLla = xyzToLla(toSprite.position) //@TODO fix!
        const toLla = { lat:toData[5], lon:toData[6], alt:100}
        setToLlaPosition(
            toTextSprite
          , toLla.lat      // same latitude
          , toLla.lon + 14 // a little way east
          , toLla.alt + 5  // a little higher in altitude
        )
    }
    resetTextSprites()



    //// TWEEN


    //// Tween definitions.
    const tweenDefs = [
        { // camera position’s altitude UP
            beginState: { alt:120 }
          , currState:  {}
          , endState:   { alt:250 }
          , beginFrac:  0
          , endFrac:    0.5
          , tween:      null
          , easing:     TWEEN.Easing.Cubic.InOut
          , onReset:    function (def) { }
          , onUpdate:   function (def) { return function () {
                cameraCurrent.position.alt = def.currState.alt
            } }
        }
      , { // camera position’s altitude DOWN
            beginState: { alt:250 }
          , currState:  {}
          , endState:   { alt:120 }
          , beginFrac:  0.5
          , endFrac:    1
          , tween:      null
          , easing:     TWEEN.Easing.Cubic.InOut
          , onReset:    function (def) { }
          , onUpdate:   function (def) { return function () {
                cameraCurrent.position.alt = def.currState.alt
            } }
        }
      , { // camera position’s latitude and longitude
            beginState: { lat:fromData[5],  lon:fromData[6] }
          , currState:  {}
          , endState:   { lat:toData[5],    lon:toData[6] }
          , beginFrac:  0 // fraction of whole duration, so `0`...
          , endFrac:    1 // ...`1` fills the entire sequence
          , tween:      null
          , easing:     TWEEN.Easing.Cubic.InOut
          , onReset:    function (def) {
                def.beginState.lat = fromData[5]
                def.beginState.lon = fromData[6]
                def.endState.lat   = toData[5]
                def.endState.lon   = toData[6]
            }
          , onUpdate:   function (def) { return function () {
                // console.log(def.currState.lat);
                cameraCurrent.position.lat = def.currState.lat
                cameraCurrent.position.lon = def.currState.lon
                setToLlaPosition(camera, cameraCurrent.position.lat, cameraCurrent.position.lon, cameraCurrent.position.alt)
                camera.lookAt(0,0,0)
            } }
        }
      , { // ‘from’ sprite - the origin
            beginState: {
                usualOpacity: usualSpriteOpacityBeginEnd
              , fromOpacity:  fromSpriteOpacityBegin
              , fromScale:    fromSprite.scale.x * 27
            }
          , currState:  {}
          , endState:   {
                usualOpacity: usualSpriteOpacityFlying
              , fromOpacity:  usualSpriteOpacityFlying
              , fromScale:    fromSprite.scale.x * 2
            }
          , beginFrac:  0.1
          , endFrac:    0.3
          , tween:      null
          , easing:     TWEEN.Easing.Cubic.Out
          , onReset:    function (def) {
                const { fromOpacity, fromScale } = def.beginState
                fromSprite.scale.set(fromScale, fromScale, fromScale)
                fromSpriteMaterial.opacity = fromOpacity
            }
          , onUpdate:   function (def) { return function () {
                const { usualOpacity, fromOpacity, fromScale } = def.currState
                fromSprite.scale.set(fromScale, fromScale, fromScale)
                fromSpriteMaterial.opacity = fromOpacity
                usualSpriteMaterial.opacity = usualOpacity
            } }
        }
      , { // ‘to’ sprite - the destination - show text and pause
            beginState: {
                toOpacity:     usualSpriteOpacityFlying
              , toTextOpacity: toTextSpriteOpacityFlying
              , toScale:       toSprite.scale.x * 2
            }
          , currState:  {}
          , endState:   {
                toOpacity:     toSpriteOpacityEnd
              , toTextOpacity: toTextSpriteOpacityEnd
              , toScale:       toSprite.scale.x * 8
            }
          , beginFrac:  0.4
          , endFrac:    0.6
          , tween:      null
          , easing:     TWEEN.Easing.Cubic.Out
          , onReset:    function (def) {
                const { toOpacity, toTextOpacity, toScale } = def.beginState
                toSprite.scale.set(toScale, toScale, toScale)
                toSpriteMaterial.opacity = toOpacity
                toTextSpriteMaterial.opacity = toTextOpacity
            }
          , onUpdate:   function (def) { return function () {
                const { toOpacity, toTextOpacity, toScale } = def.currState
                toSprite.scale.set(toScale, toScale, toScale)
                toSpriteMaterial.opacity = toOpacity
                toTextSpriteMaterial.opacity = toTextOpacity
            } }
        }
      , { // ‘to’ sprite - the destination - after pause, final zoom-in
            beginState: {
                usualOpacity: usualSpriteOpacityFlying
              , toScale:      toSprite.scale.x * 8
            }
          , currState:  {}
          , endState:   {
                usualOpacity: usualSpriteOpacityBeginEnd
              , toScale:      toSprite.scale.x * 27
            }
          , beginFrac:  0.7
          , endFrac:    0.9
          , tween:      null
          , easing:     TWEEN.Easing.Cubic.Out
          , onReset:    function (def) { }
          , onUpdate:   function (def) { return function () {
                const { usualOpacity, toScale } = def.currState
                toSprite.scale.set(toScale, toScale, toScale)
                usualSpriteMaterial.opacity = usualOpacity
            } }
        }
    ]

    //// Delete all existing tweens, and create a fresh new set.
    function resetTweens () {

        //// Stop and remove all tweens.
        tweenDefs.forEach( def => { if (def.tween) def.tween.stop() })
        TWEEN.removeAll()

        ////
        for (let i=0; i<tweenDefs.length; i++) {
            const def = tweenDefs[i]
            def.onReset(def)
            def.currState = Object.assign({}, def.beginState)
            def.tween =
                new TWEEN.Tween(def.currState)
                   .to(def.endState, (def.endFrac-def.beginFrac) * currDuration)
                   .easing(def.easing)
                   .onUpdate( def.onUpdate(def) )
                   .start(def.beginFrac * currDuration)
        }
    }




    //// SCENE


    //// Set up the scene.
    clock.stop()
    renderer.domElement.id = 'three-scene'
	renderer.setPixelRatio(pixelRatio)
	renderer.autoClear = false
	composer.addPass( new THREE.RenderPass(scene, camera) )
	composer.addPass(copyPass)
    scene.add(camera)
    scene.add(globe)
	scene.fog = new THREE.FogExp2(0x002080, 0.004) // RT: rgb(0, 90, 83)
	// scene.fog = new THREE.FogExp2((90 * 256) + 83, 0.008) // RT: rgb(0, 90, 83)
    document.body.appendChild(renderer.domElement)
    restartForPreview()




    //// CAPTURE

    const $recordpanel = document.querySelector('#recordpanel')
    $recordpanel.querySelector('button').addEventListener('mousedown', function (e) {
        onRecordButtonClick()
        captureui.settings.framerate = captureFps
        captureui.settings.resolution = `${captureWidth}x${captureHeight}`
        captureui.settings.time = captureDuration / 1000 // convert ms to seconds
        const oldFilename = captureui.settings.filename
        captureui.settings.filename =
            oldFilename.split('.')[0] + '.' + captureui.settings.format
        document.querySelector('pre').innerHTML =
            `mv $HOME/Downloads/'${captureui.settings.filename}' `
          + `'./${captureui.settings.filename}'; \n`
          + `./ffmpeg -i '${captureui.settings.filename}' -r ${fps} -filter:v `
          + `"setpts=${captureFps / fps}*PTS" `
          + `'${oldFilename}-${fps}fps.${captureui.settings.format}'; \n`
          + `unlink '${captureui.settings.filename}'`
    })




    //// RENDER


    //// Renders the scene.
    function animate () {
    	requestAnimationFrame(animate)
		const delta = clock.getDelta() // needed, to enable `clock.elapsedTime`
        const now = clock.elapsedTime
        if (prevNow === ~~now)
            if ('capture' === currMode) return // only render once a second
        else
            prevNow = ~~now // a new second!
	    TWEEN.update(now * 1000) // convert seconds to ms
		renderer.clear()
		composer.render()
    }

    //// Begin Rendering.
    animate()




    //// FUNCTIONS


    //// Resets the scene state and zeros the timer.
    function restart () {
        clock.stop()
        resetFromTo()
        resetFromToSprites()
        resetTextSprites()
        resetTweens()
        clock.start() // reset `clock.elapsedTime` to zero
    }

    //// Restarts the scene for development and previewing.
    ROOT.restartForPreview = restartForPreview
    function restartForPreview (evt) {
        if ('preview' !== currMode) {
            currMode = 'preview'
            copyPass.renderToScreen = true
            currFps = fps
            currDuration = duration
            renderer.setSize(width, height)
            composer.setSize(width * pixelRatio, height * pixelRatio)
        }
        restart()
    }


    //// Restarts the scene for capture.
    ROOT.restartForCapture = restartForCapture
    function restartForCapture () {
        if ('capture' !== currMode) {
            currMode = 'capture'
            copyPass.renderToScreen = showDuringCapture
            currFps = captureFps
            currDuration = captureDuration
            renderer.setSize(captureWidth, captureHeight)
            composer.setSize(captureWidth * pixelRatio, captureHeight * pixelRatio)
        }
        restart()
    }


    //// Restarts the scene for capturing, runs the capture and saves the video.
    function onRecordButtonClick () {
        restartForCapture()

        // threecap.record({
        //     width: captureWidth
        //   , height: captureHeight
        //   , fps: captureFps
        //   , time: duration * (fps / captureFps)
        //   , format: 'mp4'
        //   // , canvas: renderer.domElement // optional, slowest
        //   , composer: composer // optional, fastest
        //   , scriptbase: './threecap-master/build/'
        // }).then(function(video) {
        //     video.saveFile('myVideo.mp4')
        // })
    }


    function setToLlaPosition (object3d, lat, lon, alt) {
        const cosLat = Math.cos(lat * Math.PI / 180)
        const sinLat = Math.sin(lat * Math.PI / 180)
        const cosLon = Math.cos(lon * Math.PI / 180)
        const sinLon = Math.sin(lon * Math.PI / 180)
        const x = alt * cosLat * cosLon
        const y = alt * cosLat * sinLon
        const z = alt * sinLat
        object3d.position.x = x
        object3d.position.y = z // for correct THREE.js coords, swap y with z...
        object3d.position.z = - y // ...and z with negative y
    }


    //// Returns `{ lat:1, lon:2, alt:100 }`
    ////@TODO fix!
    function xyzToLla (position) { // eg `{ x:80, y:-2, z:-60 }`
        const
            alt = 100 //@TODO calc from distance to (0,0,0)
          , x = position.x   // no change!
          , z = position.y   // for correct THREE.js coords, swap y with z...
          , y = - position.z // ...and z with negative y
          , sinLat = z / alt
          , lat = Math.asin(sinLat)
          , cosLat = Math.cos(lat)
          , cosLon = y / alt / cosLat
          , lon = Math.acos(cosLon)
        return { lat, lon, alt }
    }


}(this)</script>

</body>
</html>
